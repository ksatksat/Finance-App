@model IEnumerable<FinanceApp.Models.Expense>
<h2 class ="text-center mb-3">My Expenses</h2>
<div class="container">
    <table class="table table-bordered">
        <thead class="table-light">
            <tr>
                <th>Description</th>
                <th>Amount</th>
                <th>Category</th>
                <th>Date</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach(var item in Model)
            {
                <tr>
                    <td>@item.Description</td>
                    <td>@String.Format("{0:C}",item.Amount)</td>
                    <td>@item.Category</td>
                    <td>@item.Date.ToString("yyyy-MM-dd")</td>
                    <td>
                        <a asp-action="Edit" asp-route-id="@item.Id" class="btn btn-sm btn-outline-primary">Edit</a>
                        <a asp-action="Delete" asp-route-id="@item.Id" class="btn btn-sm btn-outline-danger">Delete</a>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>
<h2 class="text-center mb-4">Expenses Overview</h2>
<div>
    <!--<canvas style="max-width:450px; max-height:450px;" id="myChart"></canvas>-->
    
    <div class="container py-3">
        <canvas id="myChart" class="d-block mx-auto" style="max-width:450px; max-height:450px; width:100%; height:auto;"></canvas>
    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
    (async () => {
      const canvas = document.getElementById('myChart');
      const ctx = canvas.getContext('2d');

      try {
        const res = await fetch('/Expenses/GetChart');
        if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
        const data = await res.json();

        console.log('Chart data:', data); // useful while developing

        const labels = data.map(d => d.category ?? d.Category ?? 'Unknown');
        const totals = data.map(d => Number(d.total ?? d.Total) || 0);

        new Chart(ctx, {
          type: 'pie',
          data: {
            labels: labels,
            datasets: [{
              label: 'Expenses',
              data: totals,
            }]
          },
          options: {
            responsive: true,
          }
        });
      } catch (err) {
        //console.error(err);
        canvas.insertAdjacentHTML('afterend',
          '<p class="text-danger">Could not load chart. See console for details.</p>');
          // Log details only when running on local dev machine
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
          console.error('Chart load error', err);
        }
      }
    })();
</script>


@*
1) View model and server-side table rendering
@model IEnumerable<FinanceApp.Models.Expense>
...
@foreach(var item in Model)
{
    <tr>
        <td>@item.Description</td>
        <td>@String.Format("{0:C}", item.Amount)</td>
        <td>@item.Category</td>
        <td>@item.Date.ToString("yyyy-MM-dd")</td>
        <td>
            <a asp-action="Edit" asp-route-id="@item.Id" class="btn btn-sm btn-outline-primary">Edit</a>
            <a asp-action="Delete" asp-route-id="@item.Id" class="btn btn-sm btn-outline-danger">Delete</a>
        </td>
    </tr>
}


@model IEnumerable<Expense> — the controller passes a sequence of 
    Expense objects to the view. This makes the view strongly 
    typed and enables asp-for / model access like @item.Description.

The foreach produces one <tr> per expense. Each <td> is a table cell:

@item.Description — HTML-encoded output of the description.

@String.Format("{0:C}", item.Amount) — formats the amount as 
currency using the server culture (e.g., $12.34). If you want 
client/user culture you must handle that separately.

@item.Date.ToString("yyyy-MM-dd") — explicit date format 
(ISO-like). This is deterministic but not localized.

The Edit and Delete links use Tag Helpers:

asp-action="Edit" + asp-route-id="@item.Id" generates the 
correct URL for the MVC action (e.g., /Expenses/Edit/123), 
respecting routing.

Note: Delete here is a link to a confirmation page (GET). The 
actual destructive action should be a POST with anti-forgery 
protection — do that in the controller.

Server-side notes

Razor expressions and formatting run on the server before 
the page is sent to the browser.

Razor output is HTML-encoded by default — that prevents 
script injection from Description.

2) Chart area (HTML/CANVAS)
<canvas id="myChart" class="d-block mx-auto" style="max-width:450px; max-height:450px; width:100%; height:auto;"></canvas>


<canvas> is the required drawing surface for Chart.js. 
    Chart.js gets the 2D context (canvas.getContext('2d')) 
    and draws the chart as pixels.

The inline CSS sets a responsive maximum size; Chart.js will 
handle pixel scaling (and devicePixelRatio) when responsive: true is set.

Accessibility

Canvas is not semantic. Add role="img" plus an aria-label or 
provide a textual fallback (or a hidden data table) for screen readers.

Example accessible markup you can add:

<canvas id="myChart" role="img" aria-label="Expenses by category pie chart" ...></canvas>
<noscript>
  <p class="text-muted">Chart requires JavaScript. See the expenses table above for the data.</p>
</noscript>

3) Loading Chart.js
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


Loads Chart.js from a CDN. In production you may 
prefer SRI (integrity) attributes or serve a local copy.

4) Client-side script — what it does and why
(async () => {
  const canvas = document.getElementById('myChart');
  const ctx = canvas.getContext('2d');

  try {
    const res = await fetch('/Expenses/GetChart');
    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
    const data = await res.json();

    console.log('Chart data:', data);

    const labels = data.map(d => d.category ?? d.Category ?? 'Unknown');
    const totals = data.map(d => Number(d.total ?? d.Total) || 0);

    new Chart(ctx, { type: 'pie', data: { labels, datasets: [{ label: 'Expenses', data: totals }] }, options: { responsive: true } });
  } catch (err) {
    canvas.insertAdjacentHTML('afterend','<p class="text-danger">Could not load chart. See console for details.</p>');
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.error('Chart load error', err);
    }
  }
})();

Step-by-step explanation

IIFE async — an immediately-invoked async function keeps 
variables local and runs when the script loads.

Get canvas context — getContext('2d') provides the drawing API Chart.js uses.

Fetch chart data — fetch('/Expenses/GetChart') calls the server 
endpoint that must return JSON (array of objects with 
category/total fields). If response status is not OK, the 
code throws an error to trigger the catch.

Recommendation: generate the URL with @Url.Action("GetChart","Expenses") 
so routing changes won’t break the code:

const url = '@Url.Action("GetChart","Expenses")';
const res = await fetch(url);


Parse JSON — await res.json() parses the JSON response into data.

Logging — console.log('Chart data:', data) is useful during dev; 
you already limit console.error to localhost only which is a 
good pattern for suppressing raw errors in production.

Build labels and totals arrays

d.category ?? d.Category ?? 'Unknown' — uses the nullish 
coalescing operator (??) to accept either category or 
Category or fall back to 'Unknown'. ?? treats only 
null/undefined as missing (not '' or 0).

Number(d.total ?? d.Total) || 0 — picks total or Total, converts 
to a number and then uses || 0 to coerce falsy values (including NaN) 
to 0. Note that || treats 0 as falsy too; in this case the fallback 
is also 0 so the result is the same, but if you want to preserve a 
real 0 you should use Number.isFinite (see improved code below).

Create Chart — new Chart(ctx, {...}) constructs a pie chart with 
those labels and totals. responsive: true allows Chart.js to 
adapt to container size.

Error handling — on any error, the code injects an inline error 
message and logs details to the console only on localhost.

5) Server-side expectation

The endpoint /Expenses/GetChart should return JSON like:

[
  { "category": "Groceries", "total": 123.45 },
  { "category": "Rent", "total": 900.00 }
]


Typical C# controller code:

var chartData = await _context.Expenses
    .GroupBy(e => e.Category)
    .Select(g => new ChartEntry { Category = g.Key, Total = g.Sum(e => e.Amount) })
    .ToListAsync();
return Ok(chartData);


Protect that endpoint (e.g., [Authorize]) and ensure it 
returns only the current user's data if multi-user.

6) Security & reliability notes

Authorization: always verify on the server that the caller 
is allowed to see the chart data.

Data validation: the client code assumes data is an array. 
If the server returns malformed JSON, res.json() may throw.

Error reporting: you already restrict console.error to localhost — 
that’s a good pattern. For production diagnostics, send sanitized 
errors to your server or telemetry service (Application Insights, Sentry).

CORS: fetching a same-origin @Url.Action avoids CORS. If you 
fetch cross-origin, configure CORS properly.

XSS: JSON data displayed by Chart.js is not inserted as 
raw HTML, so XSS risk is low — but always ensure that 
textual labels are handled carefully if used elsewhere.

7) Performance and UX suggestions

Use @Url.Action rather than hardcoded path (see above).

Preserve 0 values correctly: use a more robust numeric conversion:

const totals = data.map(d => {
  const n = Number(d.total ?? d.Total);
  return Number.isFinite(n) ? n : 0;
});


This preserves real 0 values and converts NaN/Infinity to 0.

DevicePixelRatio (sharp charts on retina):

new Chart(ctx, {
  type: 'pie',
  data: {...},
  options: { responsive: true, devicePixelRatio: window.devicePixelRatio || 1 }
});


Accessibility: add role="img" and aria-label to the canvas 
and provide a <noscript> fallback or an off-screen data 
    table for screen readers.

Retry UX: provide a retry button in the catch block so users 
can attempt to reload the chart.

Move inline script into a @section Scripts (if your layout 
supports sections) so scripts are organized and page-specific 
scripts load in the right place.

Chart colors and tooltips: set backgroundColor and tooltip 
callbacks to format numbers as localized currency for better UX.

Caching: if the chart data is heavy, add server-side caching 
or Cache-Control headers.

8) Improved, copy-paste JS (safe and production-friendly)
<script>
  (async function loadChart() {
    const canvas = document.getElementById('myChart');
    const ctx = canvas.getContext('2d');

    try {
      const res = await fetch('@Url.Action("GetChart","Expenses")');
      if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
      const data = await res.json();

      const labels = data.map(d => d.category ?? d.Category ?? 'Unknown');
      const totals = data.map(d => {
        const n = Number(d.total ?? d.Total);
        return Number.isFinite(n) ? n : 0;
      });

      new Chart(ctx, {
        type: 'pie',
        data: { labels, datasets: [{ label: 'Expenses', data: totals }] },
        options: { responsive: true, devicePixelRatio: window.devicePixelRatio || 1 }
      });
    } catch (err) {
      canvas.insertAdjacentHTML('afterend',
        '<p class="text-danger">Could not load the chart. Please try again later.</p>');
      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
        console.error('Chart load error', err);
      } else {
        // optionally POST a minimal sanitized error to server for diagnostics
      }
    }
  })();
</script>

9) Quick checklist you can apply immediately

Replace hardcoded fetch URL with @Url.Action.

Use Number.isFinite for numeric parsing.

Add role="img" and aria-label to the canvas 
+ <noscript> fallback.

Keep console.error only in dev, and consider 
server-side telemetry for production errors.

Protect /Expenses/GetChart with [Authorize] and filter by user.

*@