@model FinanceApp.Models.ViewModels.RegisterViewModel

@{
    ViewData["Title"] = "Register";
}

<h2 class="text-center mb-3">@ViewData["Title"]</h2>
@Html.ValidationSummary(true, "", new { @class = "text-danger" })

<form asp-action="Register" method="post">
    @Html.AntiForgeryToken()
    <div class="mb-3">
        <label asp-for="Email" class="form-label"></label>
        <input asp-for="Email" class="form-control" />
        <span asp-validation-for="Email" class="text-danger"></span>
    </div>

    <div class="mb-3">
        <label asp-for="Password" class="form-label"></label>
        <input asp-for="Password" class="form-control" />
        <span asp-validation-for="Password" class="text-danger"></span>
    </div>

    <div class="mb-3">
        <label asp-for="ConfirmPassword" class="form-label"></label>
        <input asp-for="ConfirmPassword" class="form-control" />
        <span asp-validation-for="ConfirmPassword" class="text-danger"></span>
    </div>
    <div class="text-center my-3">
        <button type="submit" class="btn btn-primary">Register</button>
    </div>
    
</form>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
}
@*this is the Register page counterpart to your Login view. I’ll walk through what it does, 
    why each piece is there, and give small recommendations and a simple controller 
    example so you see the full flow.

What this file does (short)

Renders a Bootstrap-styled, strongly-typed registration form bound to RegisterViewModel. 
It displays field-level validation messages, includes CSRF protection, and POSTS 
the form to the Register action.

Line / block explanation

@model FinanceApp.Models.ViewModels.RegisterViewModel
Declares the view model type. Tag helpers like asp-for are strongly typed to this 
model (e.g. Email, Password, ConfirmPassword).

@{ ViewData["Title"] = "Register"; }
Sets the page title for the layout (and is reused in the heading).

<h2 class="text-center mb-3">@ViewData["Title"]</h2>
Heading (Bootstrap classes: center + margin-bottom).

@Html.ValidationSummary(true, "", new { @class = "text-danger" })
Renders a summary for model-level errors only (the true parameter excludes 
property-level errors). Property-level errors appear next to each field via 
asp-validation-for. The text-danger class colors the summary red.

<form asp-action="Register" method="post">
Form will POST to the Register action on the current controller (Tag Helper 
asp-action builds the correct form action attribute).

@Html.AntiForgeryToken()
Inserts a hidden anti-forgery token to protect against CSRF. On the server side 
you should validate it (commonly with [ValidateAntiForgeryToken]).

Field block examples (Email, Password, ConfirmPassword)

<div class="mb-3">
    <label asp-for="Email" class="form-label"></label>
    <input asp-for="Email" class="form-control" />
    <span asp-validation-for="Email" class="text-danger"></span>
</div>


label asp-for="..." emits a <label> whose text comes from model metadata 
    (property name or [Display(Name = "...")]).

input asp-for="..." emits an <input> with id, name, and value bound to 
that property. If the model property has metadata like 
[DataType(DataType.Password)], the tag helper will render type="password".

span asp-validation-for="..." is where the field-specific 
validation message appears (client + server).

ConfirmPassword field is usually paired with a [Compare("Password")] 
data annotation in the view model so the framework validates that both match.

Submit button

<div class="text-center my-3">
    <button type="submit" class="btn btn-primary">Register</button>
</div>


Bootstrap-styled submit button.

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
Adds client-side validation scripts (typically jQuery Validate + 
unobtrusive). This enables client-side validation messages if 
you have the required script bundles in your layout.

Server-side flow (typical controller logic)

GET Register — return the view (empty model or with defaults).

POST Register — model-binding fills RegisterViewModel; server 
checks ModelState.IsValid.

If invalid, return View(model) to re-display validation messages.

If valid, create user (e.g., using ASP.NET Identity UserManager), 
sign in or redirect.

Example (ASP.NET Core Identity - minimal example):

[HttpGet]
public IActionResult Register() => View();

[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Register(RegisterViewModel model)
{
    if (!ModelState.IsValid) return View(model);

    var user = new IdentityUser { UserName = model.Email, Email = model.Email };
    var result = await _userManager.CreateAsync(user, model.Password);

    if (result.Succeeded)
    {
        await _signInManager.SignInAsync(user, isPersistent: false);
        return RedirectToAction("Index", "Home");
    }

    // Add identity errors to model state so ValidationSummary (or field messages) show them
    foreach (var error in result.Errors) ModelState.AddModelError("", error.Description);

    return View(model);
}

Recommendations / small improvements

Ensure password inputs are masked.
If your RegisterViewModel.Password and ConfirmPassword don’t have 
[DataType(DataType.Password)], the input may render as type="text". Either add the attribute on the model:

[DataType(DataType.Password)]
public string Password { get; set; }


or set type="password" explicitly in the view:

<input asp-for="Password" type="password" class="form-control" />


Use validation attributes on RegisterViewModel:

[Required] for Email/Password,

[EmailAddress] for Email,

[Compare("Password")] for ConfirmPassword,

[StringLength(...)] or custom password rules as needed.

Show friendly model-level error for a general failure (e.g., 
“Registration failed — try again”). Add it with 
ModelState.AddModelError("", "message") so it appears in ValidationSummary.

Keep Anti-forgery: keep @Html.AntiForgeryToken() and 
[ValidateAntiForgeryToken] on POST actions.

Client-side validation: ensure your _Layout includes script 
references for jQuery and jQuery Unobtrusive Validation 
so _ValidationScriptsPartial works.*@