using FinanceApp.Data;
using FinanceApp.Data.Service;
using Microsoft.EntityFrameworkCore;
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllersWithViews();
builder.Services.AddDbContext<FinanceAppContext>(options =>
    options.UseSqlServer(builder.Configuration.
    GetConnectionString("DefaultConnectionString")));
builder.Services.AddScoped<IExpensesService, ExpensesService>();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
else
{
    app.UseDeveloperExceptionPage();
}

app.UseHttpsRedirection();
app.UseRouting();

app.UseAuthorization();

app.MapStaticAssets();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}")
    .WithStaticAssets();


app.Run();

/*Migrations are a core part of the Entity Framework Core workflow and understanding them will make developing and deploying database-backed apps much easier. I’ll explain what a migration is, why you need it, the typical workflow, the pieces that EF Core creates, and best practices — with short examples so it’s practical.

What is a migration?

A migration is a set of code instructions (generated by EF Core) that describes how to change the database schema to match changes you made to your C# model classes (your DbContext and entity types).
Think of a migration as a versioned, repeatable recipe for evolving your database schema over time.

Migrations are part of the Code-First approach: you change C# classes (models), then generate SQL (via migration) to apply those changes to the database.

Why you need migrations

Keep schema and code in sync. When you add/rename/remove entities, columns, constraints, etc., the database must reflect those changes. Migrations apply them safely and in the correct order.

Version control of schema changes. Each migration is a source-code file you commit; team members can apply the same changes reproducibly.

Repeatable deployments. Migrations let you apply the same schema updates on developer machines, staging, and production.

Support for data migrations. Migrations can include data-manipulation logic (e.g., backfilling values) when you change shape of data.

Automatic detection. EF compares the model snapshot to the current model to scaffold an appropriate migration.*/

/*
this is the Program.cs (minimal-host) bootstrap for an ASP.NET Core MVC app. I’ll walk through it top-to-bottom, explain what each line does, point out a couple of non-standard lines you have (and what they likely mean), and offer small improvements you may want to add.

What this file does (high level)

This file configures and starts the web application:

Builds a WebApplicationBuilder (builder) which collects configuration and service registrations.

Registers services with the Dependency Injection container (MVC, EF Core DbContext, your app service).

Builds the WebApplication (app) which contains the middleware pipeline.

Configures request pipeline (error handling, HTTPS, routing, authorization, endpoints).

Runs the web server.

Line-by-line explanation
var builder = WebApplication.CreateBuilder(args);


Creates the builder for the minimal hosting model (aggregates configuration, logging, and DI container). args typically come from static void Main(string[] args).

builder.Services.AddControllersWithViews();


Registers MVC services for controllers and Razor views (needed for traditional MVC apps). This adds routing, model binding, view engines, etc.

builder.Services.AddDbContext<FinanceAppContext>(options =>
    options.UseSqlServer(builder.Configuration.
    GetConnectionString("DefaultConnectionString")));


Registers your Entity Framework Core DbContext (FinanceAppContext) in DI.

.UseSqlServer(...) configures EF Core to use SQL Server with a connection string fetched from configuration (appsettings.json, environment variables, or secrets). Make sure your appsettings.json has a ConnectionStrings section with key DefaultConnectionString.

builder.Services.AddScoped<IExpensesService, ExpensesService>();


Registers your IExpensesService implementation (ExpensesService) with scoped lifetime:

Scoped = one instance per HTTP request (common for DbContext-backed services).

This lets controllers get IExpensesService via constructor injection.

var app = builder.Build();


Builds the WebApplication which we will now configure (wire middleware and endpoints).

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}


Checks the environment.

If not Development (i.e., Production), it installs a generic exception handler page (redirects to /Home/Error) and enables HSTS (HTTP Strict Transport Security).

In Development you would typically want app.UseDeveloperExceptionPage() instead (helpful stack traces).

app.UseHttpsRedirection();


Redirects HTTP requests to HTTPS. Good for security.

app.UseRouting();


Adds the routing middleware. This extracts route data and prepares for endpoint matching. UseRouting() must come before UseAuthorization() and endpoint mapping.

app.UseAuthorization();


Adds authorization middleware to enforce [Authorize] attributes or policy-based authorization. If you use authentication, add app.UseAuthentication() before UseAuthorization().

app.MapStaticAssets();


Not a built-in method — likely a custom extension method in your project that maps or configures static assets (CSS/JS/images) or sets up endpoints for static content. If you don’t have this, you’d normally call app.UseStaticFiles() to serve the wwwroot files.

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}")
    .WithStaticAssets();


MapControllerRoute(...) maps the default MVC route with controller/action/id pattern. This is what enables /Expenses/Index and /Expenses/Create.

.WithStaticAssets() again looks like a custom extension that probably configures static-asset-related endpoint behavior for the route chain. This is not standard — check your project for extension methods named MapStaticAssets and WithStaticAssets to see what they do exactly.

app.Run();


Starts the web server and begins processing requests. This call blocks until the server shuts down.

 */

/*
Кратко — что делает MapStaticAssets()

MapStaticAssets() — это расширяющий метод для IEndpointRouteBuilder (то есть его обычно вызывают на app в Program.cs). Он мэпит (регистрирует) статические файлы, которые были сгенерированы во время сборки, как HTTP-эндпойнты, так чтобы эти файлы могли отдавать клиентам.

Иначе говоря: этот метод помогает автоматически подключить статические ресурсы, которые не лежат непосредственно в wwwroot, а были подготовлены на этапе сборки (например, ресурсы, упакованные в библиотеку, сгенерированные ассеты из других проектов и т.п.).

Параметры и поведение

Сигнатура (в подсказке):
IEndpointRouteBuilder.MapStaticAssets([string? staticAssetsManifestPath = null])

staticAssetsManifestPath — путь к manifest файлу, который описывает, какие статические файлы нужно смэпить.

Если передать null (по умолчанию), метод попытается использовать IHostEnvironment.ApplicationName, чтобы найти манифесты для текущего приложения.

Если указан относительный путь, то поиск будет в AppContext.BaseDirectory (обычно — папка с исполняемым файлом).

Можно указать и полный путь до манифеста, если он лежит не в стандартном месте.

Чем это отличается от UseStaticFiles() и UseBlazorFrameworkFiles()?

app.UseStaticFiles() — стандартный middleware, который отдаёт файлы из wwwroot (или из StaticFileOptions.FileProvider, если вы настроили другое место). Это middleware в pipeline обработки запросов.

app.MapStaticAssets() — мэпит файлы сгенерированные во время сборки / поставляемые манифестом как эндпойнты (специфичный механизм для build-produced assets и пакетов).

UseBlazorFrameworkFiles() — ещё одна специализированная помощница (для Blazor WASM), которая мэпит клиентские файлы Blazor. Эти вызовы могут сосуществовать — у каждого своя задача.

Если у вас обычный сайт, где все ресурсы лежат в wwwroot, то UseStaticFiles() достаточно. MapStaticAssets() нужен в более специфичных сценариях (RCL, билд-процессы, SDK-произведённые ассеты и т.п.).

Пример (минимальный Program.cs)
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();        // сервируем файлы из wwwroot
app.MapStaticAssets();       // регистрируем build-produced static assets (если есть)

app.UseRouting();
app.UseAuthorization();

app.MapControllers();
app.MapFallbackToFile("index.html");

app.Run();


Если манифест лежит в нестандартном месте:

app.MapStaticAssets("path/to/static-assets-manifest.json");

Когда это нужно на практике

Когда статические ресурсы формируются автоматически в процессе сборки (например, инструмент/пакет положил ассеты рядом с исполняемым файлом и создал manifest).

Когда используете библиотеки/пакеты, которые встраивают статические файлы и создают manifest для их экспозиции.

Для некоторых шаблонов приложений (например, SPA / Blazor) — сборщик SDK может генерировать такие manifest-файлы, и MapStaticAssets() упростит их доступ.

Как проверить, что оно сработало

Посмотрите в выходную папку (bin/…/publish или AppContext.BaseDirectory) — должен быть файл-манифест (обычно JSON) и соответствующие ассеты.

Запустите приложение и откройте URL к ожидаемому файлу — он должен отдаваться.

Включите логирование (Information/Debug) — часто там видно, какие файлы/эндпойнты были зарегистрированы.
 */

/*
Что делает WithStaticAssets()

WithStaticAssets() — это расширяющий метод, который добавляет к создаваемым эндпойнтам метаданные о статических ресурсах. В подсказке видно: он «Adds a Microsoft.AspNetCore.Components.ResourceAssetCollection metadata instance to the endpoints». То есть метод не сам отдает файлы — он помечает (помещает metadata) маршруты/экшны контроллера, чтобы другие механизмы (например, инфраструктура, читающая манифесты статических ассетов или специальная middleware/endpoint-логика) могли понять, какие сборочные/ресурсные файлы связаны с этим маршрутом и как их отдавать.

Зачем это нужно

Когда у вас есть ассеты, которые были сгенерированы/включены не в wwwroot, а через SDK/библиотеки (RCL, Blazor, build-produced assets), и эти ассеты логически «принадлежат» какому-то маршруту/файлу вашего приложения.

Добавив метаданные через WithStaticAssets(), вы связываете контроллерный маршрут с наборами статических ресурсов, которые потом будут экспонироваться (например, MapStaticAssets() или другая логика читает эти метаданные и регистрирует соответствующие конечные точки/файлы).

Параметры

Сигнатура обычно выглядит так:

ControllerActionEndpointConventionBuilder.WithStaticAssets(string? manifestPath = null)


manifestPath — опционально: путь к manifest-файлу, описывающему ресурсы. Если null, используется стандартный поиск (например, по IHostEnvironment.ApplicationName / AppContext.BaseDirectory) для нахождения manifest'ов.

Отличие от UseStaticFiles() и MapStaticAssets()

UseStaticFiles() — middleware, отдаёт файлы из wwwroot (или указанного IFileProvider).

MapStaticAssets() — регистрирует (мапит) build-produced ассеты как эндпойнты, читая manifest.

WithStaticAssets() — не отдаёт ничего сам по себе; он помечает конкретный маршрутизируемый эндпойнт (контроллер/экшн) метаданными о ресурсах, чтобы другие части инфраструктуры знали: «этот маршрут связан с такими-то статическими ассетами».

Пример использования
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}"
).WithStaticAssets(); // добавляем метаданные ассетов к этому маршруту


или с указанием манифеста:

app.MapControllerRoute(...).WithStaticAssets("path/to/static-assets-manifest.json");

Когда не нужен

Для простого сайта, где все файлы в wwwroot, WithStaticAssets() не нужен. Нужен в сценариях с RCL, Blazor/SPA и прочими пакетами/инструментами, которые создают и регистрируют ассеты через манифесты.
 */

/*
that file is an appsettings.json configuration file used 
by ASP.NET Core. It stores application settings (logging, 
host rules, connection strings, etc.) that the framework 
reads at startup via the IConfiguration system. I’ll 
explain each section, what the values mean, and give 
practical security / deployment tips.

Full file (for reference)
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnectionString": "Data Source=(localdb)\\mssqllocaldb;Initial Catalog=financeApp_data;Integrated Security=True;Pooling=False;Encrypt=False;Trust Server Certificate=True"
  }
}

Section-by-section explanation
Logging
"Logging": {
  "LogLevel": {
    "Default": "Information",
    "Microsoft.AspNetCore": "Warning"
  }
}


Controls the built-in logging behavior (what severity levels are recorded).

"Default": "Information" — by default the app will emit logs 
at Information level and above (Information, Warning, Error, Critical). 
Debug and Trace are ignored.

"Microsoft.AspNetCore": "Warning" — overrides the logging level for the 
Microsoft.AspNetCore category so framework/infrastructure logs from 
that namespace are limited to Warning+ (reduces noisy framework logs).

You can add more categories 
(e.g., "Microsoft.EntityFrameworkCore": "Information") or change 
levels for development (Debug) vs production (Warning/Error).

AllowedHosts
"AllowedHosts": "*"


Controls host header filtering when using the built-in host 
filtering middleware (UseHostFiltering / HostFiltering is 
enabled by default in some templates).

"*" means accept requests for any host header (development convenience).

For production it’s more secure to restrict to specific host names:

"AllowedHosts": "example.com;www.example.com"


This helps mitigate host header attacks.

ConnectionStrings
"ConnectionStrings": {
  "DefaultConnectionString": "Data Source=(localdb)\\mssqllocaldb;Initial Catalog=financeApp_data;Integrated Security=True;Pooling=False;Encrypt=False;Trust Server Certificate=True"
}


Standard place to store DB connection strings. Use 
builder.Configuration.GetConnectionString("DefaultConnectionString") 
or Configuration["ConnectionStrings:DefaultConnectionString"] to read it in code.

The value is a SQL Server connection string. Breakdown of the parts:

Data Source=(localdb)\\mssqllocaldb
Points to the LocalDB SQL Server instance (developer/local machine DB). 
Note the JSON \\ is an escaped backslash — correct for JSON.

Initial Catalog=financeApp_data
The database name.

Integrated Security=True
Use Windows Authentication (current Windows account). 
No DB username/password required.

Pooling=False
Disables ADO.NET connection pooling. Default is True normally; 
pooling off may be okay for local dev but you usually want 
pooling enabled (performance reason) for production.

Encrypt=False
Disables TLS encryption for SQL Server connection. On production 
you usually want Encrypt=True so traffic to the DB is encrypted.

Trust Server Certificate=True
Accepts the server certificate even if it is self-signed or 
not trusted. This is commonly used with LocalDB or dev instances 
but should not be used in production unless you understand the consequences.

How ASP.NET Core reads this

At startup WebApplication.CreateBuilder(args) wires configuration 
sources (appsettings.json, appsettings.{Environment}.json, 
environment variables, user secrets, command-line args).

Code like this uses the connection string:

builder.Services.AddDbContext<FinanceAppContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnectionString")));

Practical recommendations & security notes

Use LocalDB only for development
(localdb)\mssqllocaldb is fine for dev on Windows. For production 
use a proper SQL Server / Azure SQL instance.

Don’t store secrets in appsettings.json for production

Use environment variables, Azure Key Vault, or the Secret Manager 
for sensitive values (passwords, keys).

For example, in production store a connection string with credentials 
in an environment variable or Key Vault and keep appsettings.json commit-safe.

Switch to Encrypt=True in production
Ensure secure database connections; avoid Trust Server Certificate=True 
unless you have a trusted certificate chain or an explicit reason.

Enable connection pooling in production
Remove Pooling=False (allow default pooling) for performance.

Avoid AllowedHosts: "*" in production
Set host names explicitly to reduce attack surface.

Use environment-specific configuration
Create appsettings.Development.json / appsettings.Production.json to 
override values per environment. The environment-specific file loaded 
later will override appsettings.json settings.

Async-safe logging and filtering
If logs are noisy, tune category levels or add a structured logger 
like Serilog for file/elastic sinks and filtering.

Example: production-ready connection string (SQL authentication)
"ConnectionStrings": {
  "DefaultConnectionString": "Server=tcp:mydbserver.database.windows.net,1433;Initial Catalog=financeApp_db;User ID=dbuser;Password=YourStrongPassword!;Encrypt=True;TrustServerCertificate=False;MultipleActiveResultSets=True"
}


Uses SQL auth (User ID + Password), TLS encryption enabled, 
and MultipleActiveResultSets=True if you rely on MARS.

Important: Do not commit production passwords to source control 
— use secrets or environment variables.

How to use User Secrets (dev) / env vars (prod)

Local dev: dotnet user-secrets init then dotnet user-secrets set 
"ConnectionStrings:DefaultConnectionString" "<value>".

Production: set ConnectionStrings__DefaultConnectionString 
environment variable (note : is replaced by __).

Quick tips for debugging connection issues

Make sure LocalDB instance exists and the DB financeApp_data 
is created (migrations or Update-Database).

If connecting with Integrated Security from a service account 
(Linux container), Windows Integrated auth won't work; 
use SQL auth or a different setup.

If you get TLS/certificate errors, prefer Encrypt=True with a 
valid cert instead of Trust Server Certificate=True in production.
 */